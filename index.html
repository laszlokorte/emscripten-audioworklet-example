<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="favicon.svg" />
        <title>Emscripten Test</title>
    </head>
    <body>
        <div class="app">
            <header>
                <h1>Emscripten</h1>
                <p>Simple WASM+WebGL example using Emscripten.</p>
                <p>Click on the canvas to turn sound on/off</p>
                <button id="lkStart">Start</button>
                <button id="lkStop">Stop</button>
                <button id="lkPeep">Peep</button>
                <input
                    type="range"
                    min="1"
                    max="1000"
                    id="lkFreq"
                    value="220"
                />
                <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.01"
                    id="lkAmpl"
                    value="0.1"
                />
            </header>
            <div class="grid" id="lkGrid">
                <section>
                    <h2>Canvas</h2>
                    <canvas id="lkCanvas" width="800" height="600"></canvas>
                </section>
                <section>
                    <h2>Log</h2>
                    <pre id="lkLog"></pre>
                </section>
            </div>

            <script src="build/main.js"></script>
            <script type="module">
                const memory = new WebAssembly.Memory({
                    initial: 256,
                    maximum: 256,
                    shared: true,
                });

                const wasm = await WebAssembly.compileStreaming(
                    fetch("build/main.wasm"),
                );
                const instance = await WebAssembly.instantiate(wasm, {
                    env: {
                        memory,
                    },
                });

                const blockSize = 128;

                const samples = new Float32Array(memory.buffer, 0, blockSize);

                const audioCtx = new AudioContext({ samplingRate: 44100 });
                await audioCtx.audioWorklet.addModule("worklet.js");

                const bufferNode = new AudioWorkletNode(
                    audioCtx,
                    "wasm-processor",
                    {
                        processorOptions: { memory, wasm },
                    },
                );
                const volume = audioCtx.createGain();
                const gain = audioCtx.createGain();
                gain.gain.value = 0; // start bei 0
                instance.exports.setup();

                volume.gain.value = lkAmpl.valueAsNumber;
                bufferNode.connect(volume);
                volume.connect(gain);
                gain.connect(audioCtx.destination);
                const freqParam = bufferNode.parameters.get("freq");
                freqParam.value = lkFreq.value;
                lkPeep.addEventListener("click", async () => {
                    instance.exports.play_sound(
                        440 * Math.pow(2, Math.round(Math.random() * 12) / 12),
                    );
                });
                lkStart.addEventListener("click", async () => {
                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    lkGrid.classList.remove("loading");
                    await audioCtx.resume();
                    gain.gain.cancelScheduledValues(now);
                    gain.gain.setValueAtTime(gain.gain.value, now);
                    gain.gain.linearRampToValueAtTime(
                        1,
                        audioCtx.currentTime + fadeTime,
                    );
                    requestAnimationFrame(draw);
                });
                lkStop.addEventListener("click", async () => {
                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    await audioCtx.resume();
                    gain.gain.cancelScheduledValues(now);
                    gain.gain.linearRampToValueAtTime(
                        gain.gain.value,
                        audioCtx.currentTime,
                    );
                    gain.gain.linearRampToValueAtTime(
                        0.0,
                        audioCtx.currentTime + fadeTime,
                    );
                });

                lkFreq.addEventListener("input", async (evt) => {
                    freqParam.setValueAtTime(
                        evt.currentTarget.valueAsNumber,
                        audioCtx.currentTime,
                    );
                });

                lkAmpl.addEventListener("input", async (evt) => {
                    volume.gain.value = evt.currentTarget.valueAsNumber;
                });
                window.addEventListener("pointermove", (evt) => {
                    if (evt.shiftKey) {
                        const dx = evt.clientX - window.innerWidth / 2;
                        const dy = evt.clientY - window.innerHeight / 2;
                        lkFreq.value = Math.round(Math.hypot(dx, dy) + 1);

                        freqParam.setValueAtTime(
                            lkFreq.value,
                            audioCtx.currentTime,
                        );
                    }
                });

                const drawCtx = lkCanvas.getContext("2d");
                drawCtx.fillStyle = "#fed";
                drawCtx.fillRect(0, 0, lkCanvas.width, lkCanvas.height);
                let x = 0;
                function draw() {
                    drawCtx.fillStyle = "#fed";
                    const blockSize = 128;
                    const samples = new Float32Array(
                        memory.buffer,
                        0,
                        blockSize,
                    );
                    const s = [...samples];
                    drawCtx.fillStyle = "#fed";
                    drawCtx.fillRect(0, 0, blockSize, lkCanvas.height);

                    drawCtx.fillStyle = "maroon";

                    for (let i = 0; i < blockSize; i++) {
                        drawCtx.fillRect(
                            i,
                            lkCanvas.height / 2,
                            1,
                            ((s[i] * lkCanvas.height) / 2) *
                                volume.gain.value *
                                gain.gain.value,
                        );
                    }
                    x = instance.exports.get_sample();

                    x =
                        ((((x + blockSize) % lkCanvas.width) + lkCanvas.width) %
                            lkCanvas.width) -
                        blockSize;

                    requestAnimationFrame(draw);
                }
            </script>
            <style>
                body {
                    font-family: monospace;
                    margin: 0;
                }
                h1 {
                    grid-column: 1 / -1;
                    grid-row: 1 / span 1;
                    margin: 0;
                }
                h2 {
                    margin: 0;
                }
                .app {
                    padding: 2em;
                    display: flex;
                    flex-direction: column;
                    gap: 1em;
                }
                .grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(18em, 1fr));
                    grid-template-rows: auto 1fr;
                    gap: 1em;
                    justify-content: stretch;
                    align-items: stretch;
                }
                .loading {
                    opacity: 0.1;
                }
                section {
                    display: flex;
                    flex-direction: column;
                    justify-content: stretch;
                    flex-grow: 1;
                }
                pre {
                    background-color: #111;
                    color: #fff;
                    padding: 1em;
                    margin: 0;
                    flex-grow: 1;
                }
                canvas {
                    background-color: lemonchiffon;
                }
                summary {
                    padding: 1em;
                    cursor: pointer;
                    background-color: #eee;
                    user-select: none;
                }
                .scroller {
                    max-height: 30vh;
                    overflow: auto;
                }
            </style>
            <details>
                <summary>Sourcecode</summary>
                <pre id="lkSource" class="scroller"><script>
                            window.addEventListener('DOMContentLoaded', () => {
                              const log = lkLog.innerText
                              lkLog.innerText = ''
                              lkSource.removeChild(lkSource.firstElementChild)
                              lkSource.appendChild(document.createTextNode(document.documentElement.outerHTML));

                              lkLog.innerText = log
                            })
                            </script></pre>
            </details>
        </div>
    </body>
</html>
